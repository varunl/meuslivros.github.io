<?xml version='1.0' encoding='utf-8'?>
<html xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Microservices at Scale</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body data-type="book" class="calibre">
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 11. Microservices at Scale">
<div class="preface" id="at-scale-chapter">
<section data-type="sect1" data-pdf-bookmark="Scaling">
<div class="preface" id="idp11977920">
<section data-type="sect2" data-pdf-bookmark="Starting Again"><div class="preface" id="idp12027664">
<h2 class="calibre15" id="calibre_pb_17">Starting Again</h2>

<p class="author"><a data-type="indexterm" data-primary="scaling" data-secondary="vs. redesign" id="idp12028944" class="calibre3"></a><a data-type="indexterm" data-primary="redesign" id="idp12029920" class="calibre3"></a>The architecture that gets you started may not be the architecture that keeps you going when your system has to handle very different volumes of load. As Jeff Dean said in his presentation “Challenges in Building Large-Scale Information Retrieval Systems” (WSDM 2009 conference), you should “design for ~10× growth, but plan to rewrite before ~100×.” At certain points, you need to do something pretty radical to support the next level of growth.</p>

<p class="author">Recall the story of Gilt, which we touched on in <a data-type="xref" href="part0008_split_000.html#deployment-chapter" class="calibre3">Chapter 6</a>. A simple monolithic Rails application did well for Gilt for two years. Its business became increasingly successful, which meant more customers and more load. At a certain tipping point, the company had to redesign the application to handle the load it was seeing.</p>

<p class="author">A redesign may mean splitting apart an existing monolith, as it did for Gilt. Or it might mean picking new data stores that can handle the load better, which we’ll look at in a moment. It could also mean adopting new techniques, such as moving from synchronous request/response to event-based systems, adopting new deployment platforms, changing whole technology stacks, or everything in between.</p>

<p class="author">There is a danger that people will see the need to rearchitect when certain scaling thresholds are reached as a reason to build for massive scale from the beginning. This can be disastrous. At the start of a new project, we often don’t know exactly what we want to build, nor do we know if it will be successful. We need to be able to rapidly experiment, and understand what capabilities we need to build. If we tried building for massive scale up front, we’d end up front-loading a huge amount of work to prepare for load that may never come, while diverting effort away from more important activities, like understanding if anyone will want to actually use our product. Eric Ries tells the story of spending six months building a product that no one ever downloaded. He reflected that he could have put up a link on a web page that 404’d when people clicked on it to see if there was any demand, spent six months on the beach instead, and learned just as much!</p>

<p class="author">The need to change our systems to deal with scale isn’t a sign of failure. It is a sign of success.<a data-type="indexterm" data-startref="ix_scaling" id="idp12035440" class="calibre3"></a></p>
</div></section>





</div></section>













</div></section></body></html>
