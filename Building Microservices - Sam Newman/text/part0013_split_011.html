<?xml version='1.0' encoding='utf-8'?>
<html xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Microservices at Scale</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body data-type="book" class="calibre">
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 11. Microservices at Scale">
<div class="preface" id="at-scale-chapter">
<section data-type="sect1" data-pdf-bookmark="Scaling"><div class="preface" id="idp11977920">
<h1 class="calibre7" id="calibre_pb_11">Scaling</h1>

<p class="author"><a data-type="indexterm" data-primary="scaling" data-secondary="reasons for" id="idp11997120" class="calibre3"></a><a data-type="indexterm" data-primary="microservices at scale" data-secondary="scaling" id="idp12100288" class="calibre3"></a><a data-type="indexterm" data-primary="scaling" id="ix_scaling" class="calibre3"></a>We scale our systems in general for one of two reasons. First, to help deal with failure: if we’re worried that something will fail, then having more of it will help, right? Second, we scale for performance, either in terms of handling more load, reducing latency, or both. Let’s look at some common scaling techniques we can use and think about how they apply to microservice architectures.</p>








</div></section>













</div></section></body></html>
