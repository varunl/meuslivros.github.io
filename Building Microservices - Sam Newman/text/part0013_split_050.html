<?xml version='1.0' encoding='utf-8'?>
<html xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Microservices at Scale</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body data-type="book" class="calibre">
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 11. Microservices at Scale">
<div class="preface" id="at-scale-chapter">
<section data-type="sect1" data-pdf-bookmark="Documenting Services">
<div class="preface" id="idp12335664">
<section data-type="sect2" data-pdf-bookmark="HAL and the HAL Browser"><div class="preface" id="idp12344624">
<h2 class="calibre15" id="calibre_pb_50">HAL and the HAL Browser</h2>

<p class="author"><a data-type="indexterm" data-primary="documentation" data-secondary="HAL (Hypertext Application Language)" id="idp12346000" class="calibre3"></a><a data-type="indexterm" data-primary="HAL (Hypertext Application Language)" id="idp12347104" class="calibre3"></a><a data-type="indexterm" data-primary="microservices at scale" data-secondary="self-describing systems" id="idp12347712" class="calibre3"></a><a data-type="indexterm" data-primary="self-describing systems" id="idp12348656" class="calibre3"></a><a data-type="indexterm" data-primary="documentation" data-secondary="self-describing systems" id="idp12349408" class="calibre3"></a><a data-type="indexterm" data-primary="UDDI (Universal Description, Discovery, and Integration)" id="idp12350352" class="calibre3"></a><a data-type="indexterm" data-primary="humane registry" id="idp12351072" class="calibre3"></a>By itself, the <a href="http://bit.ly/hal-spec" class="calibre3">Hypertext Application Language (HAL)</a> is a standard that describes standards for hypermedia controls that we expose. As we covered in <a data-type="xref" href="part0006_split_000.html#integration-chapter" class="calibre3">Chapter 4</a>, hypermedia controls are the means by which we allow clients to progressively explore our APIs to use our service’s capabilities in a less coupled fashion than other integration techniques. If you decide to adopt HAL’s hypermedia standard, then not only can you make use of a wide number of client libraries for consuming the API (at the time of writing, the HAL wiki listed 50 supporting libraries for a number of different languages), but you can also make use of the HAL browser, which gives you a way to explore the API via a web browser.</p>

<p class="author">Like Swagger, this UI can be used not only to act as living documentation, but also to execute calls against the service itself. Executing calls isn’t quite as slick, though. Whereas with Swagger you can define templates to do things like issue a POST request, with HAL you’re more on your own. The flipside to this is that the inherent power of hypermedia controls lets you much more effectively explore the API exposed by the service, as you can follow links around very easily. It turns out that web browsers are pretty good at that sort of thing!</p>

<p class="author">Unlike with Swagger, all the information needed to drive this documentation and sandbox is embedded in the hypermedia controls. This is a double-edged sword. If you are already using hypermedia controls, it takes little effort to expose a HAL browser and have clients explore your API. However, if you aren’t using hypermedia, you either can’t use HAL or have to retrofit your API to use hypermedia, which is likely to be an exercise that breaks existing consumers.</p>

<p class="author">The fact that HAL also describes a hypermedia standard with some supporting client libraries is an added bonus, and I suspect is a big reason why I’ve seen more uptake of HAL as a way of documenting APIs than Swagger for those people already using hypermedia controls. If you’re using hypermedia, my recommendation is to go with HAL over Swagger. But if you’re using hypermedia and can’t justify the switch, I’d definitely suggest giving Swagger a go.</p>
</div></section>





</div></section>













</div></section></body></html>
