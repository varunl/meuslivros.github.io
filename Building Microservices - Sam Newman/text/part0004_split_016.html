<?xml version='1.0' encoding='utf-8'?>
<html xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>The Evolutionary Architect</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body data-type="book" class="calibre">
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. The Evolutionary Architect">
<div class="preface" id="architect-chapter">
<section data-type="sect1" data-pdf-bookmark="Governance Through Code">
<div class="preface" id="idp4143088">
<section data-type="sect2" data-pdf-bookmark="Tailored Service Template"><div class="preface" id="idp4614656">
<h2 class="calibre15" id="calibre_pb_16">Tailored Service Template</h2>

<p class="author"><a data-type="indexterm" data-primary="standards enforcement" data-secondary="tailored service templates" id="idp4616064" class="calibre3"></a><a data-type="indexterm" data-primary="tailored service templates" id="idp4617104" class="calibre3"></a><a data-type="indexterm" data-primary="service templates" id="idp4617792" class="calibre3"></a><a data-type="indexterm" data-primary="templates" id="idp4618464" class="calibre3"></a>Wouldn’t it be great if you could make it really easy for all developers to follow most of the guidelines you have with very little work? What if, out of the box, the developers had most of the code in place to implement the core attributes that each service needs?</p>

<p class="author"><a data-type="indexterm" data-primary="Dropwizard" id="idp4619808" class="calibre3"></a><a data-type="indexterm" data-primary="Karyon" id="idp4620512" class="calibre3"></a><a href="http://dropwizard.io/" class="calibre3">Dropwizard</a> and <a href="http://bit.ly/1JtA6KX" class="calibre3">Karyon</a> are two open source, JVM-based microcontainers. They work in similar ways, pulling together a set of libraries to provide features like health checking, serving HTTP, or exposing metrics. So, out of the box, you have a service complete with an embedded servlet container that can be launched from the command line. This is a great way to get going, but why stop there? While you’re at it, why not take something like a Dropwizard or Karyon, and add more features so that it becomes compliant for your context?</p>

<p class="author"><a data-type="indexterm" data-primary="circuit breakers" id="idp4623376" class="calibre3"></a><a data-type="indexterm" data-primary="Hystrix library" id="idp4624080" class="calibre3"></a><a data-type="indexterm" data-primary="Metrics library" id="idp4624752" class="calibre3"></a>For example, you might want to mandate the use of circuit breakers. In that case, you might integrate a circuit breaker library like <a href="http://bit.ly/1wxQtwW" class="calibre3">Hystrix</a>. Or you might have a practice that all your metrics need to be sent to a central Graphite server, so perhaps pull in an open source library like Dropwizard’s <a href="http://bit.ly/1yVt4LN" class="calibre3">Metrics</a> and configure it so that, out of the box, response times and error rates are pushed automatically to a known location.</p>

<p class="author">By tailoring such a service template for your own set of development practices, you ensure that teams can get going faster, and also that developers have to go out of their way to make their services badly behaved.</p>

<p class="author">Of course, if you embraced multiple disparate technology stacks, you’d need a matching service template for each. This may be a way you subtly constrain language choices in your teams, though. If the in-house service template supports only Java, then people may be discouraged from picking alternative stacks if they have to do lots more work themselves. Netflix, for example, is especially concerned with aspects like fault tolerance, to ensure that the outage of one part of its system cannot take everything down. To handle this, a large amount of work has been done to ensure that there are client libraries on the JVM to provide teams with the tools they need to keep their services well behaved. Anyone introducing a new technology stack would mean having to reproduce all this effort. The main concern for Netflix is less about the duplicated effort, and more about the fact that it is so easy to get this wrong. The risk of a service getting newly implemented fault tolerance wrong is high if it could impact more of the system. Netflix mitigates this by using <em class="calibre4">sidecar services</em>, which communicate locally with a JVM that is using the appropriate libraries.</p>

<p class="author">You do have to be careful that creating the service template doesn’t become the job of a central tools or architecture team who dictates how things should be done, albeit via code. Defining the practices you use should be a collective activity, so ideally your team(s) should take joint responsibility for updating this template (an internal open source approach works well here).</p>

<p class="author">I have also seen many a team’s morale and productivity destroyed by having a mandated framework thrust upon them. In a drive to improve code reuse, more and more work is placed into a centralized framework until it becomes an overwhelming monstrosity. If you decide to use a tailored service template, think very carefully about what its job is. Ideally, its use should be purely optional, but if you are going to be more forceful in its adoption you need to understand that ease of use for the developers has to be a prime guiding force.</p>

<p class="author">Also be aware of the perils of shared code. In our desire to create reusable code, we can introduce sources of coupling  between services. At least one organization I spoke to is so worried about this that it actually copies its service template code manually into each service. This means that an upgrade to the core service template takes longer to be applied across its system, but this is less concerning to it than the danger of coupling. Other teams I have spoken to have simply treated the service template as a shared binary dependency, although they have to be very diligent in not letting the tendency for DRY (don’t repeat yourself) result in an overly coupled system! This is a nuanced topic, so we’ll explore it in more detail in <a data-type="xref" href="part0006_split_000.html#integration-chapter" class="calibre3">Chapter 4</a>.<a data-type="indexterm" data-startref="ix_SAstenf" id="idp4633712" class="calibre3"></a></p>
</div></section>





</div></section>













</div></section></body></html>
