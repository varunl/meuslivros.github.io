<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter&#xA0;6.&#xA0;Writing Consumers</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="chapter" title="Chapter&#xA0;6.&#xA0;Writing Consumers"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter&#xA0;6.&#xA0;Writing Consumers</h1></div></div></div><p>Consumers<a id="id135" class="indexterm"/> are the applications that consume the messages published by Kafka producers and process the data extracted from them. Like producers, consumers can also be different in nature, such as applications doing real-time or near-real-time analysis, applications with NoSQL or data warehousing solutions, backend services, consumers for Hadoop, or other subscriber-based solutions. These consumers can also be implemented in different languages such as Java, C, and Python.</p><p>In this chapter, we will focus on the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Kafka API for message consumers</li><li class="listitem" style="list-style-type: disc">Simple Java-based Kafka consumers</li><li class="listitem" style="list-style-type: disc">Java-based Kafka consumers consuming partitioned messages</li></ul></div><p>At the end of the chapter, we will explore some of the important properties required for a Kafka consumer. So, let's start.</p><div class="mediaobject"><img src="graphics/7938OS_06_01.jpg" alt="Writing Consumers"/></div><p>In the next few sections, <a id="id136" class="indexterm"/>we will discuss the API provided by Kafka for writing Java-based custom consumers.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>All the Kafka classes referred to in this book are actually written in Scala.</p></div></div><div class="section" title="Java consumer API"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec28"/>Java consumer API</h1></div></div></div><p>Kafka <a id="id137" class="indexterm"/>provides two types of API for Java consumers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The high-level consumer API</li><li class="listitem" style="list-style-type: disc">The simple consumer API</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The high-level consumer API provides an abstraction over the low-level implementation of the consumer API, whereas the simple consumer API provides more control to the consumer by allowing it to override its default low-level implementation.</p></div></div><div class="section" title="High-level consumer API"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec26"/>High-level consumer API</h2></div></div></div><p>The high-level consumer API <a id="id138" class="indexterm"/>is used <a id="id139" class="indexterm"/>when only data is needed and the handling of message offsets is not required. Hence, most of the low-level details are abstracted during message consumption. The high-level consumer stores the last offset read from a specific partition in ZooKeeper. This offset is stored based on the consumer group name provided to Kafka at the beginning of the process.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Message offset is the position within the message partition to know where the consumer left off consuming the message.</p></div></div><p>The consumer group name is unique and global across the Kafka cluster and any new consumers with an in-use consumer group name may cause ambiguous behavior in the system. When a new process is started with the existing consumer group name, Kafka triggers rebalance between the new and existing process threads for the consumer group. Post rebalance, some of the messages that are intended for a new process may go to an old process, causing unexpected results. To avoid this ambiguous behavior, any existing consumers should be shut down before starting new consumers for an existing consumer group name.</p><p>The following are the classes that are imported to write Java-based basic consumers using the high-level consumer API for a Kafka cluster:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>KafkaStream</strong></span>: Objects <a id="id140" class="indexterm"/>of the <code class="literal">kafka.consumer.KafkaStream</code> class are returned by the <code class="literal">ConsumerConnector</code> implementation. <a id="id1410" class="indexterm"/>This list of the <code class="literal">KafkaStream</code> objects is returned for each topic, which can further create an iterator shown as follows over messages in the stream:<div class="informalexample"><pre class="programlisting">class KafkaStream[K,V]</pre></div><p>Here, the parameters <code class="literal">K</code> and <code class="literal">V</code> specify the type for the partition key and message value, respectively.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ConsumerConfig</strong></span>: The <a id="id1420" class="indexterm"/><code class="literal">kafka.consumer.ConsumerConfig</code> class encapsulates the property values required for <a id="id1430" class="indexterm"/>establishing the connection with ZooKeeper, such as ZooKeeper URL, group ID, ZooKeeper session timeout, and ZooKeeper sink time.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ConsumerConnector</strong></span>: Kafka <a id="id1440" class="indexterm"/>provides <a id="id1450" class="indexterm"/>the <code class="literal">ConsumerConnector</code> interface (<code class="literal">interface</code> <code class="literal">ConsumerConnector</code>) which is further implemented by ZookeeperConsumerConnector class<code class="literal"> </code>(<code class="literal">kafka.javaapi.consumer.ZookeeperConsumerConnector</code>). This class is responsible for all the interaction of a consumer with ZooKeeper.<p>The following is the class diagram for the <code class="literal">ConsumerConnector</code> class:</p><div class="mediaobject"><img src="graphics/7938OS_06_02.jpg" alt="High-level consumer API"/></div></li></ul></div></div><div class="section" title="Simple consumer API"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec27"/>Simple consumer API</h2></div></div></div><p>Features such<a id="id1460" class="indexterm"/> as setting the initial offset <a id="id1470" class="indexterm"/>when restarting the consumer are not provided by the high-level consumer API. The simple consumer API provides low-level control to Kafka consumers for partition consumptions, for example, multiple reads for the same message or managing transactions, and so on.</p><p>Compared to <a id="id1480" class="indexterm"/>high-level consumer API, developer needs to put in extra efforts to gain this low-level control within consumers, that is, consumers need to keep track of offsets and also need to figure out the lead broker for the topic and partition, and so on.</p><p>The main class used within the simple consumer <a id="id1490" class="indexterm"/>API is <code class="literal">SimpleConsumer</code>
<a id="id15000" class="indexterm"/> (<code class="literal">kafka.javaapi.consumer.SimpleConsumer</code>). The following<a id="id1510" class="indexterm"/> is the class diagram for the <code class="literal">SimpleConsumer</code> class:</p><div class="mediaobject"><img src="graphics/7938OS_06_03.jpg" alt="Simple consumer API"/></div><p>A simple consumer<a id="id1520" class="indexterm"/> class provides a connection to the lead broker for fetching the messages from the topic and methods to get the topic metadata and the list of offsets.</p><p>A few more important classes for building different request objects are <code class="literal">FetchRequest</code> (<code class="literal">kafka.api.FetchRequest</code>), <code class="literal">OffsetRequest</code> (<code class="literal">kafka.javaapi.OffsetRequest</code>), <code class="literal">OffsetFetchRequest</code> (<code class="literal">kafka.javaapi.OffsetFetchRequest</code>), <code class="literal">OffsetCommitRequest</code> (<code class="literal">kafka.javaapi.OffsetCommitRequest</code>), and <code class="literal">TopicMetadataRequest</code> (<code class="literal">kafka.javaapi.TopicMetadataRequest</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>The following examples in this chapter are based on the high-level consumer API. For examples based on the simple consumer API, refer to <a class="ulink" href="https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+SimpleConsumer+Example">https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+SimpleConsumer+Example</a>.</p></div></div></div></div></div></body></html>
