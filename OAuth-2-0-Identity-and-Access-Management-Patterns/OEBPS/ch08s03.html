<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Security considerations</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Security considerations"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec37"/>Security considerations</h1></div></div></div><p>One general piece of advice that applies to every type of application development is to develop the software with security in mind, meaning it is more expensive for an error-prone application to first implement the needed features and after that to make modifications in them to enforce security. Instead, this should be done simultaneously.</p><p>In this chapter we are raising security awareness, and next we will learn about which measures we can apply and what we can do in order to have more secure applications.</p><div class="section" title="Use TLS"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec46"/>Use TLS</h2></div></div></div><p>
<span class="strong"><strong>TLS</strong></span>
<a id="id361" class="indexterm"/> (the cryptographic protocol named <span class="strong"><strong>Transport</strong></span> <span class="strong"><strong>Layer Security</strong></span>) is the result of the standardization of the SSL protocol (Version 3.0), which was developed by Netscape and was proprietary. Thus,<a id="id362" class="indexterm"/> in various documents and specifications, we can find the use of TLS and SSL interchangeably, even though there are actually differences in the protocol.</p><p>From a security standpoint, it is recommended that all requests sent from the client during the execution of a grant flow are done over TLS. In fact, it is recommended TLS be used on both sides of the connection.</p><p>OAuth 2.0 relies heavily <a id="id363" class="indexterm"/>on TLS; this is done in order to maintain confidentiality of the exchanged data over the network by providing encryption and integrity on top of the connection between the client and server. In retrospect, in OAuth 1.0 the use of TLS was not mandatory, and parts of the authorization flow (on both server side and client side) had to deal with cryptography, which resulted in various implementations, some good and some sloppy.</p><p>When we make an HTTP request (for example, in order to execute some OAuth 2.0 grant flow), in order to make the connection secure the HTTP client library that is used to execute the request has to be configured to use TLS.</p><p>TLS is to be used by the client application when sending requests to both authorization and resource servers, and is to be used by the servers themselves as well. The result is an end-to-end TLS protected connection. If end-to-end protection cannot be established, it is advised to reduce the scope and lifetime of the access tokens that are issued by the authorization server.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>The OAuth2.0 specification states that the use of TLS is mandatory when sending requests to the authorization and token endpoints and when sending requests using password authentication. Access tokens, refresh tokens, username and password combinations, and client credentials must be transmitted with the use of TLS.</p></div></div><p>By using TLS, the attackers that are trying to intercept/eavesdrop the exchanged information during the execution of the grant flow will not be able to do so. If TLS is not used, attackers can eavesdrop on an access token, an authorization code, a username and password combination, or other critical information.</p><p>This means that the use of TLS prevents man-in-the-middle attacks and replaying of already fulfilled requests (also called replay attacks). By performing replay attempts, the attackers can issue themselves<a id="id364" class="indexterm"/> new access tokens or can perform replays on a request towards resource servers and modify or delete data belonging to the resource owner.</p><p>Last but not least, the authorization server can enforce the use of TLS on every endpoint in order to reduce the risk <a id="id365" class="indexterm"/>of phishing attacks.</p></div><div class="section" title="Ensure web server application protection"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec47"/>Ensure web server application protection</h2></div></div></div><p>For client applications that are <a id="id366" class="indexterm"/>actually web applications deployed on a server, there are numerous protection measures that can be<a id="id367" class="indexterm"/> taken into account so that the server, the database, and the configuration files are kept safe.</p><p>The list is not limited and can vary between scenarios and environments; some of the key measures are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Install recommended security additions and tools for the given web and database servers that are in use.</li><li class="listitem" style="list-style-type: disc">Restrict remote administrator access only to the people that require it (for example, for server maintenance and application monitoring).</li><li class="listitem" style="list-style-type: disc">Regulate which server user can have which roles, and regulate permissions for the resources available to them.</li><li class="listitem" style="list-style-type: disc">Disable or remove unnecessary services on the server.</li><li class="listitem" style="list-style-type: disc">Regulate the database connections so that they are only available to the client application.</li><li class="listitem" style="list-style-type: disc">Close unnecessary open ports on the server; leaving them open can give an advantage to the attacker.</li><li class="listitem" style="list-style-type: disc">Configure protection against SQL injection.</li><li class="listitem" style="list-style-type: disc">Configure database and file encryption for vital information stored (credentials and so on). Avoid storing credentials in plain text format.</li><li class="listitem" style="list-style-type: disc">Keep the software components that are in use updated in order to avoid security exploitation.</li><li class="listitem" style="list-style-type: disc">Avoid security misconfiguration.</li></ul></div><p>It is important to have in mind<a id="id368" class="indexterm"/> what kind of web server it is, which database is used, which modules the client application uses, and on which services the client application depends, so that we can research how to apply the security measures appropriately.</p><p>
<span class="strong"><strong>OWASP</strong></span>
<a id="id369" class="indexterm"/> (<span class="strong"><strong>Open Web Application Security Project</strong></span>) provides additional documentation on security measures and describes the industry's best practices regarding software security. It is an additional resource recommended for reference and research on this topic, and can be<a id="id370" class="indexterm"/> found<a id="id371" class="indexterm"/> at <a class="ulink" href="https://www.owasp.org">https://www.owasp.org</a>.</p></div><div class="section" title="Ensure mobile and desktop application protection"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec48"/>Ensure mobile and desktop application protection</h2></div></div></div><p>Mobile and desktop applications<a id="id372" class="indexterm"/> can be installed on devices and machines that can be part of internal/enterprise or external environments. <a id="id373" class="indexterm"/>They are more vulnerable compared to the applications deployed on regulated server environments. <a id="id374" class="indexterm"/>Attackers have a better chance to try to extract the source code from the applications and other data that comes with them.</p><p>In order to provide the best possible security, some of the key measures are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use secure storage mechanisms provided by additional programming libraries and by features offered by the operating system for which the application is developed.</li><li class="listitem" style="list-style-type: disc">In multiuser operating systems, store user specific data such as credentials or access and refresh tokens in locations that are not available to other users on the same system.</li><li class="listitem" style="list-style-type: disc">As mentioned previously, credentials should not be stored in plain text format and should be encrypted.</li><li class="listitem" style="list-style-type: disc">If using an embedded database (such as SQLite in most cases), try to enforce security measures against SQL injection and encrypt the vital information (or encrypt the whole embedded database).</li><li class="listitem" style="list-style-type: disc">For mobile devices, advise the end user to utilize device lock (usually with a PIN, password, or face unlock).</li><li class="listitem" style="list-style-type: disc">Implement an optional PIN or password lock on the application level that the end user can activate if desired (which can also serve as an alternative to the previous locking measure).</li><li class="listitem" style="list-style-type: disc">Sanitize and validate the value from any input fields that are used in the applications, in order to avoid code injection, which can lead to changing the behavior or exposeing data stored by the client application.</li><li class="listitem" style="list-style-type: disc">When the application is ready to be packaged for production use (to be used by end users), perform code analysis for obfuscating code and removing the unused code. This will produce a smaller client application in file size, which will perform the same but it will be harder to reverse engineer.</li></ul></div><p>As usual, for additional reference and<a id="id375" class="indexterm"/> research we can refer to the<a id="id376" class="indexterm"/> OAuth2.0 threat model RFC document, to OWASP, and to security documentation specific to the programming language, tools, libraries, and <a id="id377" class="indexterm"/>operating system that the client application is built for.</p></div><div class="section" title="Utilize the state parameter"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec49"/>Utilize the state parameter</h2></div></div></div><p>As mentioned, with this parameter<a id="id378" class="indexterm"/> the state between<a id="id379" class="indexterm"/> the request and the callback is maintained. Even if it is an optional parameter it is highly advisable to use, and the value from the callback response will be validated if it is equal to the one that was sent.</p><p>When setting the value for the state parameter in the request</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Don't use predictable values that can be guessed by attackers.</li><li class="listitem" style="list-style-type: disc">Don't repeat the same value often between requests.</li><li class="listitem" style="list-style-type: disc">Don't use values that can contain and expose some internal business logic of the system and can be used maliciously if discovered.</li><li class="listitem" style="list-style-type: disc">Use session values: If the user agent&#x2014;with which the user has authenticated and approved the authorization request&#x2014;has its session cookie available, calculate a hash from it and use that one as the state value.</li><li class="listitem" style="list-style-type: disc">Or use some string generator: If a session variable is not available as an alternative, we can use some generated programmable value. Some real world implementations do this by generating unique identifiers and using them as state values, commonly achieved by generating a random <span class="strong"><strong>UUID</strong></span> (<span class="strong"><strong>universally unique identifier</strong></span>)<a id="id380" class="indexterm"/> and converting it to a hexadecimal value.</li><li class="listitem" style="list-style-type: disc">Keep track of which<a id="id381" class="indexterm"/> state value was set for which request (user session in most cases) and redirect URI, in order to validate that the returned one contains an equal value.</li></ul></div></div><div class="section" title="Use refresh tokens when available"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec50"/>Use refresh tokens when available</h2></div></div></div><p>For client applications<a id="id382" class="indexterm"/> that have obtained an access token and a<a id="id383" class="indexterm"/> refresh token along with it, upon access token expiry it is a good practice to request a new one by using the refresh token instead of going through the whole grant flow again.</p><p>With this measure we are transmitting less data over the network and are providing less exposure that the attacker<a id="id384" class="indexterm"/> can monitor.</p></div><div class="section" title="Request the needed scope only"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec51"/>Request the needed scope only</h2></div></div></div><p>As briefly mentioned previously in this chapter, it is highly advisable to specify only the required scope<a id="id385" class="indexterm"/> when requesting an access token instead of specifying the maximum one that is available.</p><p>With this measure, if an attacker <a id="id386" class="indexterm"/>gets hold of the access token, he can take damaging actions only to the level specified by the scope, and not more. This is done for damage minimization until the token is revoked and invalidated.</p></div></div></body></html>
