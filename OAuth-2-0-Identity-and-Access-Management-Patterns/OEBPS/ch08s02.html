<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>OAuth 2.0 security features</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="OAuth 2.0 security features"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec36"/>OAuth 2.0 security features</h1></div></div></div><p>OAuth 2.0 provides several features<a id="id331" class="indexterm"/> that are a part of the protocol and are related to improving security and dealing with attacks. We'll explore them one by one, by briefly explaining what each feature does, and what purpose it serves regarding security.</p><div class="section" title="Scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec39"/>Scope</h2></div></div></div><p>In the various <a id="id332" class="indexterm"/>authorization grant flows we encountered the parameter <code class="literal">scope</code>, <a id="id333" class="indexterm"/>which is used by the clients to specify in the request which type of access is to be granted to them on behalf of the resource owner, and is used by authorization servers in the response to confirm the same.</p><p>When an access token is issued to<a id="id334" class="indexterm"/> a client application, the scope specified in it defines the access authorization associated for that particular token. It defines which resources and API methods on these resources the client application can access and execute with the given access token.</p><p>Security wise,<a id="id335" class="indexterm"/> with scope in OAuth2.0 we can:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reduce the type of access from the client application to the resource server to the level that is really needed</li><li class="listitem" style="list-style-type: disc">Minimize the damage an attacker can perform if an access token is stolen</li><li class="listitem" style="list-style-type: disc">Have an overview of the API methods that are accessible by a client with a given token</li></ul></div><p>Additionally, also for damage minimization, the client application can request a lesser scope than the one already granted for its access token.</p></div><div class="section" title="Token lifetime"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec40"/>Token lifetime</h2></div></div></div><p>Another protocol parameter is <code class="literal">expires_in</code>, which we receive as a part of the response from the authorization <a id="id336" class="indexterm"/>server when the client application requests an access token. This parameter states the lifetime of the issued access token in seconds, and if the value of this lifetime is small they are called short-lived access tokens.</p><p>Security wise, this parameter is<a id="id337" class="indexterm"/> used to limit the duration of the lifetime so that stolen tokens will have less time to be abused in doing damaging actions. The less secure the client application is, the more short-lived the access token received by the authorization server should be. The same applies for tokens sent over non-secure channels.</p></div><div class="section" title="The refresh token"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec41"/>The refresh token</h2></div></div></div><p>The refresh token is a parameter,<a id="id338" class="indexterm"/> named <code class="literal">refresh_token</code>, <a id="id339" class="indexterm"/>that is also received as a part of the response from the authorization server when the client application requests an access token. Except for the<a id="id340" class="indexterm"/> client credentials grant, where it is explicitly excluded, in all grant flows defined in OAuth 2.0 it is an optional parameter that can be included in the response from the authorization server.</p><p>The purpose of the refresh token is to give the client application the possibility of renewing (or in other words, to refresh) the expired access token without redoing the whole grant flow from the start. It can ask the authorization server directly to issue a new access token.</p><p>The refresh token is mapped to the particular client application for which it was granted together with the access token. This means an access token can be renewed only with the same client credentials that were used when it was retrieved.</p><p>From a security standpoint, <a id="id341" class="indexterm"/>the use of refresh tokens:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Helps in minimizing <a id="id342" class="indexterm"/>the involvement of end-user input by direct communication between the client and authorization server. This results in fewer spots that can be vulnerable or attacked and also results in less data being transmitted over the network.</li><li class="listitem" style="list-style-type: disc">Combines well with the use of short-lived access tokens, resulting in a good security practice where the client again can have lengthy access to protected resources, but by refreshing several access tokens.</li></ul></div><p>Related to refresh tokens, the OAuth 2.0 specification also mandates:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">That the confidentiality<a id="id343" class="indexterm"/> of refresh tokens must be maintained by the client application</li><li class="listitem" style="list-style-type: disc">That the refresh tokens are transmitted from/to the authorization server only by using TLS</li><li class="listitem" style="list-style-type: disc">That the authorization server<a id="id344" class="indexterm"/> will implement techniques against attackers such as guessing refresh tokens</li></ul></div></div><div class="section" title="Authorization code"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec42"/>Authorization code</h2></div></div></div><p>When using the<a id="id345" class="indexterm"/> authorization code grant, we learned that first the end user has to approve the authorization request, usually in some web interface; <a id="id346" class="indexterm"/>after that the authorization server sends an authorization code to the client application, and after that this code is used by the client to request an access token (and optionally a refresh token).</p><p>After a successful end user authorization process, the authorization code is sent to the client's redirect URI (also called callback URI).</p><p>The authorization code grant is a browser-based redirection flow, meaning a web interface is opened in the browser or as a component in a desktop or mobile application, in which the end user has to approve or deny the authorization request. Attackers can try to access the URI parameters, the browser cache, and so on.</p><p>Due to this fact, we have the<a id="id347" class="indexterm"/> following security precautions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Instead of sending the access token, the authorization code is sent first, as an intermediary.</li><li class="listitem" style="list-style-type: disc">The authorization code has a very short lifetime.</li><li class="listitem" style="list-style-type: disc">After the client application has retrieved the authorization code, when requesting the access token with it, it is authenticated by the authorization server. This authentication is more secure and simple because it is performed directly.</li></ul></div></div><div class="section" title="Redirect URI"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec43"/>Redirect URI</h2></div></div></div><p>The<a id="id348" class="indexterm"/> redirect URI parameter<a id="id349" class="indexterm"/>, also called callback, and named <code class="literal">redirect_uri</code> <a id="id350" class="indexterm"/>in the protocol, is used by the client application to specify to the authorization server which address to return any information to when processing its request.</p><p>It is used in the authorization code grant, to hand over the authorization code on this URI back to the client, and in the implicit grant to hand over an access token in the same manner.</p><p>The main purpose of the redirect URI is preventing phishing attacks (for example, a compromised client<a id="id351" class="indexterm"/> application changes the URI to point in some other direction in order that the attacker gets the authorization code). In order<a id="id352" class="indexterm"/> to prevent this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is a common practice for application developers to have to specify the redirect URIs when performing application registration. This way, when the client application specifies a URI that is not one of those pre-registered, the request will fail. This is especially important when using the implicit grant.</li><li class="listitem" style="list-style-type: disc">When using the authorization code grant, the client specifies the redirect URI in the request for the authorization code and it has to specify the same URI again when requesting the access token. If these two URIs are not the same, the request will fail.</li></ul></div></div><div class="section" title="State"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec44"/>State</h2></div></div></div><p>The protocol parameter <a id="id353" class="indexterm"/>named <code class="literal">state</code> is used in the<a id="id354" class="indexterm"/> authorization code and implicit grant types. It's an optional parameter that can be specified in the request for the authorization server, and closely related to the redirect URI parameter, which is specified in the request as well.</p><p>The behavior of this parameter is simple: when creating the request we add this parameter and specify some predefined value for it, for example, some random hexadecimal string or some session value, and when the server returns a response to the redirect URI, the value in the <code class="literal">state</code> parameter should be the same. In short, with this parameter the state between the request and the callback is maintained.</p><p>The main purpose of this parameter is to protect against <span class="strong"><strong>cross-site request forgery</strong></span> (<span class="strong"><strong>CSRF</strong></span>)<a id="id355" class="indexterm"/>. If the returned value for this parameter is not the same as the one in the request, and it's not due to a server <a id="id356" class="indexterm"/>error, it means that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The attacker has intercepted and modified the flow</li><li class="listitem" style="list-style-type: disc">The authorization code and/or the access token can have been stolen</li><li class="listitem" style="list-style-type: disc">The attacker has maliciously accessed protected resources and methods on behalf of the user</li></ul></div><p>If any of this scenario occurs, we should check for suspicious access tokens that have been issued and revoke<a id="id357" class="indexterm"/> them immediately.</p></div><div class="section" title="Client identifier"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec45"/>Client identifier</h2></div></div></div><p>In all OAuth2.0 grants, <a id="id358" class="indexterm"/>when performing the grant flow, <a id="id359" class="indexterm"/>for the request from the client application to be processed, among other checks and validations the identity of the client has to be verified. For this to happen, the client application specifies in the request parameters its identifier and secret, named in the protocol as <code class="literal">client_id</code> and <code class="literal">client_secret</code>.</p><p>Securitywise, the use of <a id="id360" class="indexterm"/>client identifiers</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Provides the resource owner (the end user) with information about the identity of the client application that is requesting approval.</li><li class="listitem" style="list-style-type: disc">Provides the authorization server means to determine whether the client application is already registered and if it has the rights to initiate a given OAuth2.0 grant flow. For example, if the client application is of type public (cannot keep the credentials confidential), the authorization server can deny initiation of all OAuth2.0 grant flows except for the implicit grant.</li><li class="listitem" style="list-style-type: disc">Allows the authorization server to make several securitywise associations in order to use them for security checks, such as which access tokens and which access codes are issued to which clients. After that the authorization server also associates authorization codes with redirect URIs and so on.</li></ul></div></div></div></body></html>
