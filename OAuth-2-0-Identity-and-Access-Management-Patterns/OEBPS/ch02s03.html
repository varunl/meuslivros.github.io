<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tokens</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Tokens"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Tokens</h1></div></div></div><p>There are two types of<a id="id45" class="indexterm"/> tokens in OAuth 2.0, <a id="id46" class="indexterm"/>the access token and the refresh token. The access token is the one that is used by the client application when making the requests to protected resources, and the refresh token is the one that is used to renew the access token when it is expired.</p><div class="section" title="Access token"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Access token</h2></div></div></div><p>The first thing a client must do in order to access protected resources is to obtain an<a id="id47" class="indexterm"/> access token. Or in other words, a client application first has to be authorized by the user.</p><p>When the user authorizes an<a id="id48" class="indexterm"/> application, in the end the authorization server gives the client an access token. This token is associated with the user and is used as authorization credentials when accessing the protected resources on a server, and that's why we're saying that a request is made on behalf of the user.</p><p>Let's see an example<a id="id49" class="indexterm"/> of an access token response in JSON format that a client may get from a successful authorization request:</p><div class="informalexample"><pre class="programlisting">{
  "access_token":"exampleAccessTokenValue",
  "expires_in":3600,
  "scope":"exampleScopeValue",
  "state":"exampleStateValue",
  "refresh_token":"exampleRefreshTokenValue"
}</pre></div><p>The access token response<a id="id50" class="indexterm"/> contains the following fields/parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">access_token</code>:<a id="id51" class="indexterm"/> This is a mandatory parameter, defined by a string of characters, representing an authorization on behalf of the user who authorized the request, issued to the client application.</li><li class="listitem" style="list-style-type: disc"><code class="literal">expires_in</code>:<a id="id52" class="indexterm"/> This is a mandatory parameter that tells the client application for how much time the issued token is valid. This numeric value is in seconds, so in our example this token is valid for one hour.</li><li class="listitem" style="list-style-type: disc"><code class="literal">scope</code>: <a id="id53" class="indexterm"/>This is an optional parameter defining which parts (or types) of protected resources can be accessed on behalf of the user. More information on access scope is provided later in this chapter.</li><li class="listitem" style="list-style-type: disc"><code class="literal">state</code>:<a id="id54" class="indexterm"/> This is an optional parameter, used by the client for its own purposes, most commonly for security checks. The state value that the client application sends during the request will be the same as the one it will receive as part of the access token response, so this parameter can be used for defending against man in the middle attacks.</li><li class="listitem" style="list-style-type: disc"><code class="literal">refresh_token</code>:<a id="id55" class="indexterm"/> This parameter contains a string of characters that are to be used as a parameter when requesting a new token before its expiry. It is an optional parameter and some service providers don't use it.</li></ul></div><p>Various other <a id="id56" class="indexterm"/>parameters may<a id="id57" class="indexterm"/> be included, too, and they are specific to the service providers that included them and serve some specific business logic. For example, some may return a <code class="literal">userId</code> parameter<a id="id58" class="indexterm"/>, representing some internal identifier for the user that has authorized the request.</p><p>One of the most important fields for a client application is <code class="literal">access_token</code>. <a id="id59" class="indexterm"/>This information is used when making the requests to protected resources. After that comes <code class="literal">expires_in</code> <a id="id60" class="indexterm"/>and <code class="literal">refresh_token</code>. <a id="id61" class="indexterm"/>Before the token expires, instead of going through the whole authorization flow, the client can get a new access token in a more transparent and simpler way by using the data from these fields. This way the user won't be bothered with authorization request dialogs again and again every time the access token expires.</p><p>It is important to<a id="id62" class="indexterm"/> store the <code class="literal">access_token</code> and the <code class="literal">refresh_token</code> in a secure way in the client application database, and it is a good practice to store and utilize properly all the fields that come with the access token response.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>The token response and other data that is exchanged in the OAuth 2.0 flow can be transferred in various data formats; the most commonly used formats are JSON and XML.</p></div></div></div><div class="section" title="Refresh token"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Refresh token</h2></div></div></div><p>Access tokens should always expire; it's a rare case to have an access token that has an infinite lifetime, which is also <a id="id63" class="indexterm"/>considered a bad security practice. When a given access token used by the client has expired, the next time the client tries to use it to access some protected resources, it will get an error from the server.</p><p>The client uses the refresh token<a id="id64" class="indexterm"/> to get a new access token, by contacting the authorization server and <a id="id65" class="indexterm"/>supplying the data from the <code class="literal">refresh_token</code> field<a id="id66" class="indexterm"/>. If this data is valid, the authorization server returns a new access token response to the client.</p></div></div></body></html>
