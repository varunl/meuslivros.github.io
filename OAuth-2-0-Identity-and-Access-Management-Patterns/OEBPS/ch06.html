<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter&#xA0;6.&#xA0;OAuth for Mobile Applications</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="chapter" title="Chapter&#xA0;6.&#xA0;OAuth for Mobile Applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter&#xA0;6.&#xA0;OAuth for Mobile Applications</h1></div></div></div><p>In the previous chapters, we learned how to use OAuth 2.0 in the client-side applications, such as public clients that are unable to keep the client identifier and client secret confidential, and in web applications that are considered confidential clients. In the first case we used the authorization code grant flow and in the second case the implicit grant flow is used.</p><p>Now, as we move on to the mobile client applications, we may ask ourselves which OAuth 2.0 grant flow should be used. The answer is that both authorization code grant and implicit grant are suitable, and depending on the security environment the proper one is to be chosen. If the mobile operating system provides methods for secure storage, then the authorization code grant can be used; if not, the implicit grant can be used.</p><p>In this chapter we'll see how client applications for Android and iOS can use these grants. If the target/favorite mobile platform is not one of these two, you need not worry as the principles and advice mentioned in this chapter are applicable to every modern mobile operating system.</p><div class="section" title="Custom URL scheme"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec28"/>Custom URL scheme</h1></div></div></div><p>Let's suppose that we are registering<a id="id230" class="indexterm"/> the application on the authorization server to get the needed details such as <code class="literal">client_id</code> in order to implement a successful flow. Registration is covered in detail in <a class="link" href="ch03.html" title="Chapter&#xA0;3.&#xA0;First Step for Your Application">Chapter 3</a>, <span class="emphasis"><em>First Step for Your Application</em></span> with one difference: the callback endpoint (also known as the<a id="id231" class="indexterm"/> <code class="literal">redirect_uri</code> parameter) is not the same.</p><p>In both authorization code and implicit grants, the callback endpoint is the URL to which the authorization server redirects back and returns the information to the client application.</p><p>Here, first we have to register a custom URL scheme with the client application, a scheme that will be applicable on an operating system level, enabling us to forward all redirects to our client application.</p><p>For example, we may specify that the <code class="literal">redirect_uri</code> parameter will have the following form:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">app123://cb</code>
</pre></div><p>This will replace, for example, the following one: <code class="literal">https://client.example.com/cb</code>. This also means that the <code class="literal">app123</code> scheme is in use, the scheme is the first part of the URL.</p><p>Every time a URL that uses this scheme is opened, our client application will be launched to handle it and, when the authorization server redirects back to the client with the authorization response, the<a id="id232" class="indexterm"/> client application will handle that as well.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>If the mobile operating system provides no support for the custom URL schemes, or we don't want to use them for some reason, a conventional redirect URI can be used, as long as the application has access to the addresses being requested in the user agent.</p></div></div><div class="section" title="Android"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec26"/>Android</h2></div></div></div><p>To register a custom <a id="id233" class="indexterm"/>URL scheme in Android, <a id="id234" class="indexterm"/>all we have to do is edit the <code class="literal">AndroidManifest.xml</code> file and include the following code in the appropriate activity block:</p><div class="informalexample"><pre class="programlisting">&lt;intent-filter&gt;
    &lt;data android:scheme="app123" /&gt;
    &lt;action android:name="android.intent.action.VIEW" /&gt;
    &lt;category android:name="android.intent.category.DEFAULT" /&gt;
    &lt;category android:name="android.intent.category.BROWSABLE" /&gt;
&lt;/intent-filter&gt;</pre></div><p>And when handling the event, use the following code:</p><div class="informalexample"><pre class="programlisting">Uri data = getIntent().getData(); 
if (data != null) { 
  // handler logic
}</pre></div></div><div class="section" title="iOS"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec27"/>iOS</h2></div></div></div><p>Registration of a custom<a id="id235" class="indexterm"/> URL scheme in iOS<a id="id236" class="indexterm"/> is somewhat similar to Android but instead of a textual editor we use a graphical editor. We open the application's<code class="literal">-info.plist</code> file from the XCode project navigator, and it will show a table with the following columns: <code class="literal">Key</code>, <code class="literal">Type,</code> and <code class="literal">Value</code>.</p><p>Next, we expand the row with the <code class="literal">URL Types</code> key; it will show an <code class="literal">Item 0</code> field, and we add two new rows inside it with the following keys:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>URL identifier</strong></span>:<a id="id237" class="indexterm"/> This will have some values that will be a unique string, for example <code class="literal">com.packtpublishing.oauth.mobile</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>URL schemes</strong></span>: <a id="id238" class="indexterm"/>This will be an array and will have one string item, which will have the <code class="literal">app123</code> value</li></ul></div><p>Or if we open this file with a textual editor, the content of this configuration will look like the following code:</p><div class="informalexample"><pre class="programlisting">&lt;key&gt;CFBundleURLTypes&lt;/key&gt;
    &lt;array&gt;
        &lt;dict&gt;
            &lt;key&gt;CFBundleURLName&lt;/key&gt;
            &lt;string&gt;com.packtpublishing.oauth.mobile&lt;/string&gt;
        &lt;/dict&gt;
        &lt;dict&gt;
            &lt;key&gt;CFBundleURLSchemes&lt;/key&gt;
            &lt;array&gt;
                &lt;string&gt;app123&lt;/string&gt;
            &lt;/array&gt;
        &lt;/dict&gt;
    &lt;/array&gt;</pre></div><p>And that's it! To handle this<a id="id239" class="indexterm"/> event in iOS we implement <a id="id240" class="indexterm"/>the following method:</p><div class="informalexample"><pre class="programlisting">- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url {
  // handler logic
}</pre></div></div></div></div></body></html>
