<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Benefits of OAuth 2.0</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="section" title="Benefits of OAuth 2.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Benefits of OAuth 2.0</h1></div></div></div><p>To have a glimpse into the benefits<a id="id4" class="indexterm"/>, without going technical (which is the point in the next chapters), several scenarios follow.</p><div class="section" title="API security"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>API security</h2></div></div></div><p>Imagine an enterprise providing an API for some customers (be it RESTful, SOAP-based, and so on). In order to make it secure and to have regulated access to it, one way is to use the so called basic authentication, <a id="id5" class="indexterm"/>where the username and password <a id="id6" class="indexterm"/>are sent using Base64 encoding&#x2014;but not encoded or hashed&#x2014;and <span class="strong"><strong>SSL </strong></span>is used to secure the data transfer. The drawback here is that, in this type of authentication, the user, alongside his username, enters and sends his password over the wire as well.</p><p>What can be improved? In order to secure the API with OAuth 2.0, every time a request is made to the API, instead of username and password, an access token is sent. This token is obtained by the client application before making the requests, and represents the user on whose behalf the client application is using the API.</p><p>Related scenario&#x2014;a client application, which is using the API, starts misbehaving and uses it improperly. All that has to be done is to revoke the access token, making all future requests invalid (if they are made with the same token).</p><p>Another important thing to note is that the access token can be set on how much access to have, which is called scope. So a client application may not have full API access when using access tokens. In contrast, if the client application was using username and password instead of access tokens, and these credentials were stolen, the whole API could be misused until the hijacked account is blocked.</p></div><div class="section" title="Internal enterprise applications"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Internal enterprise applications</h2></div></div></div><p>Next, imagine a company <a id="id7" class="indexterm"/>utilizing a set of enterprise applications that are used internally. Company employees have to enter username<a id="id8" class="indexterm"/> and password manually in every separate application. This poses a security risk in several areas; there are several databases storing passwords, passwords are more often sent over, and so on.</p><p>With OAuth 2.0 what can be done is to have one application where the user logs in with his username and password (the OAuth 2.0 based service provider), and in all the other applications he is simply redirected to the provider where he logged in and confirms that he wants to be authorized. This way, instead of storing passwords these applications are storing the tokens for the users. The benefit is that when a password is stolen, the user has to reset his password, compared to when a token is stolen and it is revoked (invalidated).</p><p>Another related scenario is security in <span class="strong"><strong>BYOD</strong></span> (<span class="strong"><strong>bring your own device</strong></span>)<a id="id9" class="indexterm"/> companies. If a user brings his smartphone and uses an internal company application on it, and this smartphone gets stolen<a id="id10" class="indexterm"/> or compromised, the password of the user won't be exposed and only the tokens that were in use will have to be invalidated. The user can get a new device, and when he authorizes <a id="id11" class="indexterm"/>it he will get a new token.</p></div><div class="section" title="Service integration and authorization delegation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Service integration and authorization delegation</h2></div></div></div><p>Imagine that a user has an<a id="id12" class="indexterm"/> account on a photo sharing service,<a id="id13" class="indexterm"/> and also on a print ordering service.</p><p>If these two services have OAuth 2.0 integration between them, the user can authorize the printing service to access resources <a id="id14" class="indexterm"/>from the photo sharing service on his behalf. For example, the user would log in to the photo sharing service, <a id="id15" class="indexterm"/>then would log in to the printing service and request the integration, after which the user is redirected back to the photo sharing service, where he<a id="id16" class="indexterm"/> approves the authorization request.</p><p>From this point on, the printing service has an access token on behalf of this user, and can be aware which photos the user has uploaded. And the user can access the photos on the printing service without re-uploading them again there, but retrieved via the photo sharing service.</p><p>The best part of it is that the user hasn't given the username and password combination to the printing service, but instead the printing service has received an access token when it was authorized by the user.</p><p>This shows one of the key strengths of using OAuth 2.0&#x2014;authorization delegation. With OAuth 2.0 you can give access to your data/resources on some service to another one, and easily revoke this access when you change your mind. This applies everywhere, from internal enterprise applications to various services such as social media applications.</p></div><div class="section" title="Federated identity"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Federated identity</h2></div></div></div><p>Another key<a id="id17" class="indexterm"/> strength of OAuth 2.0 is federated identity.</p><p>With federated identity<a id="id18" class="indexterm"/>, a person's digital identity and details (such as e-mail, name and surname, and gender) can be linked between several distinct services.</p><p>The previous two examples show this, but let's see another example; users can log in to one OAuth 2.0 provider (for example, Facebook or LinkedIn) and then log into other web services via this provider, without entering new username and password. For example, a user wants to leave a comment on some blog post and needs to be identified in order for the comment to be accepted.</p><p>This case is also known<a id="id19" class="indexterm"/> as using OAuth 2.0 for authentication. The client application (for example, the blogging platform) is requesting only the user's information after it got authorized and nothing more.</p></div><div class="section" title="Easier service monitoring"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Easier service monitoring</h2></div></div></div><p>Last but not least,<a id="id20" class="indexterm"/> enterprises can track and monitor more easily <a id="id21" class="indexterm"/>which access token is making which request; based on this they can make calculations and gain better insight about which services <a id="id22" class="indexterm"/>are used more often by its clients, and make optimizations.</p></div></div></body></html>
